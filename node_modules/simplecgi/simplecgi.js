/*******************************************************************************
*                                                                              *
*           SimpleCGI (see http://www.rozek.mobi/Node.js/SimpleCGI)            *
*                                                                              *
*******************************************************************************/

/**** module dependencies ****/

  var express = require('express');         // assert availability of Express.js
  var fs      = require('fs')
  var path    = require('path');
  var url     = require('url');
  var util    = require('util');

  var spawn = require('child_process').spawn;

//------------------------------------------------------------------------------
// SimpleCGI                                             CGI middleware factory
//------------------------------------------------------------------------------

  var SimpleCGI = function SimpleCGI (
    CGIProcessor,                       // file path of the actual CGI processor
    CGIBaseFolder,          // (document root) folder containing all CGI scripts
    ScriptNameRule      // RegEx for extraction of CGI script path from URL path
  ) {
    if ((CGIProcessor === undefined) || (CGIProcessor === null)) {
      throw new Error('MissingArgument: no "CGIProcessor" given');
    };

    if (typeof(CGIProcessor) !== 'string') {
      throw new Error('IllegalArgument: the given "CGIProcessor" is not of type "string"');
    };

    CGIProcessor = CGIProcessor.trim();

    if (CGIProcessor === '') {
      throw new Error('EmptyArgument: the given "CGIProcessor" is empty');
    };

    if (!fs.existsSync(CGIProcessor)) {         // a synchronous call is ok here
      throw new Error('InvalidArgument: the given "CGIProcessor" does not exist');
    };

    var FileInfo = fs.statSync(CGIProcessor);   // a synchronous call is ok here

    if (!FileInfo.isFile()) {
      throw new Error('InvalidArgument: the given "CGIProcessor" is not a file');
    };

// TODO: test CGIProcessor for being executable

    if ((CGIBaseFolder === undefined) || (CGIBaseFolder === null)) {
      throw new Error('MissingArgument: no "CGIBaseFolder" given');
    };

    if (typeof(CGIBaseFolder) !== 'string') {
      throw new Error('IllegalArgument: the given "CGIBaseFolder" is not of type "string"');
    };

    CGIBaseFolder = CGIBaseFolder.trim();

    if (CGIBaseFolder === '') {
      throw new Error('EmptyArgument: the given "CGIBaseFolder" is empty');
    };

    if (!fs.existsSync(CGIBaseFolder)) {        // a synchronous call is ok here
      throw new Error('InvalidArgument: the given "CGIBaseFolder" does not exist');
    };

    FileInfo = fs.statSync(CGIBaseFolder);      // a synchronous call is ok here

    if (!FileInfo.isDirectory()) {
      throw new Error('InvalidArgument: the given "CGIBaseFolder" is not a directory');
    };

// TODO: test CGIBaseFolder for being readable

    if ((ScriptNameRule === undefined) || (ScriptNameRule === null)) {
      throw new Error('MissingArgument: no "ScriptNameRule" given');
    };

    if (typeof(ScriptNameRule) === 'string') {
      ScriptNameRule = ScriptNameRule.trim();

      if (ScriptNameRule === '') {
        throw new Error('EmptyArgument: the given "ScriptNameRule" is empty');
      };

      ScriptNameRule = new RegExp(ScriptNameRule);
    } else {
      if (!(ScriptNameRule instanceof RegExp)) {
        throw new Error('IllegalArgument: the given "ScriptNameRule" is neither a RegExp nor a string');
      };
    };

//---- processCGIrequest - actually processes an incoming CGI request ----------

    var processCGIrequest = function processCGIrequest (
      req, res, next, parsedURL, ScriptName, ScriptPath
    ) {
      var ServerEnv = process.env;

      var CGIEnv = {};
      for (var Key in ServerEnv) {
        if (ServerEnv.hasOwnProperty(Key)) {
          CGIEnv[Key] = ServerEnv[Key];
        };
      };

      CGIEnv['AUTH_TYPE']            = (req.headers['authorization'] || '').replace(/^.*: */,'').replace(/ .*$/,'');
      CGIEnv['CONTENT_LENGTH']       = req.headers['content-length'] || '0';
      CGIEnv['CONTENT_TYPE']         = req.headers['content-type'] || '';
      CGIEnv['DOCUMENT_ROOT']        = CGIBaseFolder;
      CGIEnv['GATEWAY_INTERFACE']    = 'CGI/1.1';
      CGIEnv['HTTP_ACCEPT']          = req.headers['accept'] || '*/*';;
//feb      CGIEnv['HTTP_ACCEPT_CHARSET']  = req.acceptedCharsets.join(',');
    CGIEnv['HTTP_ACCEPT_ENCODING'] = '';
//feb      CGIEnv['HTTP_ACCEPT_LANGUAGE'] = req.acceptedLanguages.join(',');
      CGIEnv['HTTP_CONNECTION']      = req.headers['connection'] || '';
      CGIEnv['HTTP_COOKIE']          = req.headers['set-cookie'] || req.headers['cookie'] || '';
      CGIEnv['HTTP_HOST']            = req.headers['host'] || '';
      CGIEnv['HTTP_REFERER']         = req.headers['referer'] || '';
      CGIEnv['HTTP_USER_AGENT']      = req.headers['user-agent'] || '';
      CGIEnv['PATH_INFO']            = parsedURL.pathname.slice(
        parsedURL.pathname.indexOf(ScriptName) + ScriptName.length
      ) + (parsedURL.hash || '').replace(/[?].*$/,''); // add anchors to path info
      CGIEnv['PATH_TRANSLATED']      = ScriptPath;  // required by LiveCode Server
      CGIEnv['QUERY_STRING']         = (parsedURL.query || '');
        if ((parsedURL.hash || '').indexOf('?') > -1) {
          CGIEnv['QUERY_STRING'] = parsedURL.hash.replace(/^.*[?]/,'');
        };     // query strings behind a "#" will not be recognized by url.parse
      CGIEnv['REMOTE_ADDR']          = req.connection.remoteAddress;
      CGIEnv['REMOTE_HOST']          = '';  // avoid the effort of a DNS request
      CGIEnv['REMOTE_IDENT']         = '';
      CGIEnv['REMOTE_PORT']          = req.connection.remotePort;
      CGIEnv['REMOTE_USER']          = (parsedURL.auth || '').replace(/:.*$/,'');
        if (req.headers['authorization']) {
          try {
            var decodedString = new Buffer(
              req.headers['authorization'].replace(/^.* /,''), 'base64'
            ).toString('binary');

            CGIEnv['REMOTE_USER'] = decodedString.replace(/:.*$/,'');
          } catch (Signal) { /* nop */ };
        };
      CGIEnv['REQUEST_METHOD']       = req.method.toUpperCase();
      CGIEnv['REQUEST_URI']          = req.url;
      CGIEnv['SCRIPT_FILENAME']      = ScriptPath;
      CGIEnv['SCRIPT_NAME']          = ScriptName;
      CGIEnv['SERVER_ADDR']          = req.socket.localAddress;
      CGIEnv['SERVER_ADMIN']         = '(none)';
      CGIEnv['SERVER_NAME']          = '';  // avoid the effort of a DNS request
      CGIEnv['SERVER_PORT']          = req.socket.localPort;
      CGIEnv['SERVER_PROTOCOL']      = req.protocol.toUpperCase() + '/' + req.httpVersion;
      CGIEnv['SERVER_SIGNATURE']     = 'Node.js with Express.js and SimpleCGI';
      CGIEnv['SERVER_SOFTWARE']      = 'Node.js ' + process.version;

    /**** spawn the actual CGI processor invocation ****/

      var CGIProcess = spawn(CGIProcessor, [], {
        cwd: CGIBaseFolder,
        env: CGIEnv
      });

      req.pipe(CGIProcess.stdin);          // provides request body as CGI stdin
      
      // feb next 3 lines
      //console.log("SIMPLECGI$$$$$$$$$$$$$$$$$$$do i get this far? "+stdin);
      //var std = CGIProcess.stdin;
      //console.log("what is stdin: " + std.length);

      CGIProcess.on('error', function (Error) {            // log any CGI errors
        console.log('CGI Processor failed: ', Error);
        try {
          if (DataBuffer !== null) {   // status must be set before body is sent
            res.send(500, 'CGI Processor failed (see log file)');
          } else {
            res.end();              // unfortunately, client can not be informed
          };
        } catch (Signal) { /* nop - it might be too late to send s.th. */ };
      });

      CGIProcess.on('exit', function (Code, Signal) {// log unexpected CGI exits
        if (Code !== 0) {
          console.log('CGI Processor exited with code %d', Code);
          try {
            if (DataBuffer !== null) { // status must be set before body is sent
              res.send(500, 'CGI Processor failed (see log file)');
            } else {
              res.end();            // unfortunately, client can not be informed
            };
          } catch (Signal) { /* nop - it might be too late to send s.th. */ };
        };
      });

      CGIProcess.stderr.on('data', function (Chunk) {//log any CGI stderr output
        console.log('CGI Script "%s" reported on stderr: "%s"', ScriptName, Chunk);
      });

      var DataBuffer = '';                  // auxiliary buffer for HTTP headers
      CGIProcess.stdout.on('data', function (Chunk) {
        if (DataBuffer !== null) {        // we are still processing any headers
          DataBuffer += Chunk;

          var LFPosition;                       // position of next LF in Buffer
          while ((LFPosition = DataBuffer.indexOf('\r\n')) >= 0) { // process headers line by line
            if (LFPosition === 0) {                    // end of headers reached
              if (res.statusCode === 204) {    // do not expect any body content
                return res.end();
              };

              if (DataBuffer.length > 2) {  // remaining content is part of body
                if (!res.getHeader('content-type')) {
                  res.setHeader('content-type','application/octet-stream');
                };

                res.write(DataBuffer.slice(2),'binary');
              };
              DataBuffer = null;                     // indicates end of headers

              return;
            };

          /**** process given header (if it looks like one) ****/

            var Header = DataBuffer.slice(0,LFPosition);
            if (Header.search(/^[a-zA-Z0-9-]+:/) === -1) {// not an HTTP header!
              if (!res.getHeader('content-type')) {
                res.setHeader('content-type','application/octet-stream');
              };

              res.write(DataBuffer,'binary');   // make it part of result's body
              DataBuffer = null;                     // indicates end of headers

              return;
            };

            DataBuffer = DataBuffer.slice(LFPosition+2);        // remove header

            var HeaderKey   = Header.replace(/:.*$/,'').toLowerCase();
            var HeaderValue = Header.replace(/^.*:/,'');

            if (HeaderKey === 'status') {//express wants to know the status code
              res.statusCode = parseInt(HeaderValue,10) || 200;
            } else {                        // other headers may be set directly
              try {
                res.setHeader(HeaderKey, HeaderValue);
              } catch (Signal) { /* nop - never trust any CGI processor*/ };
            };
          };
        } else {                           // we are already processing the body
          res.write(Chunk,'binary');
        };
      });

      CGIProcess.stdout.on('end', function () {
        if (DataBuffer !== null) {
          if (DataBuffer !== '') {                               // flush buffer
            if (!res.getHeader('content-type')) {
              res.setHeader('content-type','application/octet-stream');
            };

            res.write(DataBuffer,'binary');
          } else {                        // there does not seem to be any body
            if (res.statusCode === 200) {             // use 204 instead of 200
              res.statusCode = 204;
            };
          };
        };

        res.end();
      });
    };

//---- here comes the actual Express.js "Middleware" ---------------------------

    return function CGIHandler (req, res, next) {
      var parsedURL = url.parse(req.url);

      var RuleMatch = parsedURL.pathname.match(ScriptNameRule);
      if (RuleMatch === null) {
        res.send(500,'the given "ScriptNameRule" did not isolate the CGI script');
        return;
      };

      var ScriptName = RuleMatch[0];
      if (ScriptName.charAt(0) === '/') { ScriptName = ScriptName.slice(1) };

      var ScriptPath = path.join(CGIBaseFolder, ScriptName);
      fs.exists(ScriptPath, function (ScriptExists) {
        if (!ScriptExists) {         // the requested CGI script does not exist
          return res.send(404);
        };

        fs.stat(ScriptPath, function (Error, ScriptInfo) {
          if (Error) {
            res.send(500,'unable to inspect the requested CGI script');
            return;
          };

          if (!ScriptInfo.isFile()) {                     // not really a script
            res.send(500,'the requested CGI script is not a regular file');
            return;
          };

          fs.exists(CGIProcessor, function (ProcessorExists) {
            if (!ProcessorExists) {    // the given CGI processor doe not exist!
              res.send(500,'the foreseen CGI processor could not be found');
              return;
            };

            try {
              processCGIrequest(req, res, next, parsedURL, ScriptName, ScriptPath);
            } catch (Signal) {
              console.log('internal error: ', Signal);
              try {
                res.send(500, 'internal error (see logs file)');
              } catch (Signal) { /* nop - might be too late to send s.th. */ };
            };
          });
        });
      });
    };
  };

/**** export CGI middleware factory ****/

  module.exports = SimpleCGI;